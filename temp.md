Tomcat调优

JVM调优

jvm参数类型

1. 标配参数：-version -help -showversion跟个版本间很稳定 

2. X参数: -Xint 解释执行 -Xcomp第一次使用就编译成本地代码  -Xmixed 混合使用

3. XX参数(重点)：

   > 又可分为：
   >
   > 1. boolean类型：公式 -XX:+或者-某个属性值 表示开启或者关闭，比如是否打印GC收集(-XX:+PrintGCDetails表示开启，-XX:-PrintGCDetails表示关闭);是否设置为串行垃圾收集器(-XX:-UseSerialGC/-XX:+UseSerialGC )。
   >
   > 2. KV类型(设值类型)：-XX:属性key=value，比如：-XX:MetaspacesSize=128m设置元空间，-XX:MaxTenuringThreshold=15(新生代经历过多次GC晋升到老年代)。
   >
   > 



-Xms1024等价于-XX:InitialHeapSize=1024m 

-Xmx1024等价于-XX:MaxHeapSize=1024m

相当于比较常用，JVM给参数起的别名。



> jps：相当于 linux下的 ps命令
>
> jinfo：打印出当前JVM常用信息，包括环境变量，VM Flags 系统命令行参数等。
>
> jmap：堆内存统计，好用但慎用。
>
> jstack：查询当前时刻，线程，栈的使用情况，查看当前锁状态等。
>
> jstat：







**查看jvm初始化默认值**

> java  -XX+PrintFlagsInitial

**查看jvm修改更新项**

> java  -XX+PrintFlagsFinal

=和:=的区别：=表示JVM默认， :=表示根据系统情况修改过的值。



-Xss:线程栈的大小 相当于 -XX:ThreadStackSize 默认为0代表采用系统默认值（1024K）而非默认大小是0。



-XX:SurvivorRatio默认8表示8:1:1

-XX:NewRatio：配置新生代与老年代的比例,默认值2(分母的大小，分子为1，分子表示新生代，分母为+1),新生代占1老年代占2。占比表示 1/(2+1)。

-XX:MaxTenuringThreshold

查看jvm默认值 

jinfo: -XX+PrintFlagsInitial

+PrintCommendLineFlags

+PrintGCDetails



jps 

jinfo

jinfo -flag PrintGCDetails <pid>



jinfo -flag <options> <pid>：查指定选项的值 

jinfo -flags <pid>：查所有选项

jstack





jdk1.8之后元空间会报内存溢出吗(元空间放在本地内存上，为什么会呢)：



mysql怎么实现的事务，分库分表的实现方式。









1)TCP的三次握手和四次挥手过程，为什么是三次握手不是两次或者四次，还有过程中处于的每个状态的名称

三次握手：

1. client(closed->syn-sent) ----SYN=1 seq=x---->  server(closed->listen)。
2. server(listen->syn-rcvd)----SYN=1 ACK=1 seq=y, ack=x+1----->client(syn-sent)。
3. (client(syn-sent->estab-lished)) --ACK=1 seq=x+1 ack=y+1 server(listen->->estab-lished)

四次挥手：

2）HTTP协议与TCP协议的区别

HTTP是应用层协议，TCP是传输层协议。Http是基于TCP之上的协议。

3）HTTP协议与HTTPS协议的区别

两者都是无状态的协议，Https是一种加密协议。当初次建立链接时，会采用公钥认证方式识别对方身份。身份认证成功后，基于对称加密算法，进行加密通信。

4）一个用户从客户端向服务端发送信息是怎么保持状态信息（大概这个意思吧有点忘了），具体逻辑是怎么设计的。

基于cookie和session。禁用的情况下是根据URL后边携带sessionid参数。

5）会网络编程吗（忘了。。。。）

6）怎么创建线程

继承Thread或者实现runnable。或者是线程池。本质上都是Thread的子类。

7）线程和进程的区别

进程是

8）启动一个应用程序时候有几条进程，从java的角度讲（我也不知道答案是啥）
9）Java怎么连接数据库的，说一下详细步骤
10）JVM的垃圾回收

11）类的加载过程





经典的排序算法，

MySQL锁机制 explain的常用关键字，

I/O流 netty

分布式锁： redis、zk。

spring顶级接口设计

springboot启动流程

序列化的比较

apache  avro ：与编程语言无关的序列化。



###################################################################################################



## kafka

概念：

**broker**：

**集群控制器**：由broker充当，相当于是broker的leader，负责partiion分配给broker和监控broker。一个partion从属于一个broker，该broker是partion leader，可以跟随几个副本broker。

**群组协调器**：由broker充当，针对消费者而言，不同的群组（消费者groupid）会有不同的协调器。负责监控消费者群组内个消费者的状态（独立线程做心跳），如果宕机，会在几秒内进行再均衡。

**群主**：在群组协调器配合下，第一个和群主协调器进行沟通的将成为群主，群主负责从群组协调器里查看所有群成员信息，并分配对应的分区，之后将分配的结果上报给群主协调器，群主协调器再将分配的结果广播给所有的群成员（每个组员都只能看到自己的分配信息）。









消息保留策略：按时间或者按照大小，先得到满足的生效。

集群配置时：

broker.id：正整数 不重复

port：服务端口

zookeeper.connect：zk链接地址，hostname: port/path，path路径作为chroot路径，以区别于其他zk的客户端。

log.dirs：数据文件存放路径

auto. create. topics. enable：是否自动创建主题（1.生产者生产时或者消费者消费时，2.当任意一个客户端向主题发送元数据时）。默认为false。

log. retention. ms：消息保留的时间

log. retention. bytes：消息保留的总大小。

log.segment.ms：消息片段保留多久会被关闭。

log.segment.bytes：消息片段的大小。

borker中数据是以topic分类，以segment为单元进行存储的。可以指定segment的大小和关闭时间。当消息比较少时，消息已过期了，但是当前segment并未存满且segment并未关闭，这就会导致该消息不过期。

message.max.bytes：单个消息的最大字节数。



数据存放位置：

zk：broker、topic、分区等元数据；

>在kafka.0.9之前的版本里，zk还会保存消费者相关信息，比如消费者群组，主题信息，消费分区的偏移量等。

在高版本上，消费者将消费信息提交给broker而不再是zookeeper。

borker中数据是以topic分类，以segment为单元进行存储的。可以指定segment的大小和消息过期时间。当消息比较少时，消息已过期了，但是当前segment并未存满，这就会导致该消息不过期。

消费者

![消费者](D:\workspaces\typora\typora\img\kafka_sender.png)





生产消息的要素：

1. 必要（topic）
2. 非必要（分区，key，）

流程：

消息提交模式：（会将消息提交本地队列里，会有专门的单/多线程进行处理）

1. 提交并遗忘，消息提交到队列里即认为成功。
2. 同步发送：提交到队列后，通过Future对象来获取结果信息。
3. 异步发送：提交到队列的同时，会指定一个回调函数处理响应。

配置：

1. ack：0：只要提交成功就算，1：首领节点收到即可 n：表示n个节点收到，all表示所有节点。
2. buffer.memory：生产者本地缓存区大小，取决于当前待发送队列的数据量。
3. compression.type：消息发送前被压缩的方式，默认不压缩。
4. retries：重试次数。
5. client.id：标识客户端。
6. max. in. flight. requests. per. connection：生产者在收到broker响应前可以发送多少个消息，值越大 吞吐量越大，但是重试时可能会影响消息的顺序。设为1时可以保证重试时也能保证顺序。

消息key的两个作用：1.作为消息的补充 2.在分区不变的情况下，相同的key值 总是会被发送到同一分区上。



## 消费者

一个线程只能运行一个消费者、一个消费者也只能运行在一个线程内。如果需要在一个群组内运行多个消费者，必须使用多线程。

订阅类型：订阅类型可以分为全匹配和正则匹配。

正则匹配是指，topic符合订阅的正则表达式，即使是在订阅之后，新创建的的topic也会导致再均衡，导致该消费者新增的topic。

再均衡：

​	再均衡期间，整个消费群组无法进行消费，消费者当前读取状态会消失，甚至可能去刷新缓存(？？？)。

​	触发条件：消费者加入/离开 组群 增加partion 

配置：

bootstrap.server：broker的链接地址

key/value 序列化方式：

group.id：消费者分组id。同一个id隶属于同一个消费群组

轮询：是指在消费者订阅了topic之后，消费者就会处理所有的细节问题（群组协调、再均衡、发送心跳、拉取消息进行消费等）。

**提交偏移量**：消费者在消费完消息后，需要将消息的偏移量offset提交给broker。这个过程其实是消费者向一个特殊的主题_consumer_offset里发送消息，提交当前的offset。

提交策略：默认是自动提交，每过5s（由auto.commit.interval.ms控制）会提交一下offset。

再均衡监听器：再分区之前，消费者会暂停消费，提交offset，清理本地空间等。

消费者除了可以正常订阅主题外，还可以独立消费分区，这种情况下，不再进行再分区。不过当新增分区时，需要重新签订分区才能消费到所有的分区。

**深入**

1. broker以临时节点的状态存储在zk上（/broker/ids）。
2. 第一个连上zk的broker成为控制器（创建/controller），负责分区首领的选举，其他broker启动时，也会尝试创建/controller节点，不过不会成功，但是会创建watch进行监视该节点。当控制器宕机后，其他broker由于有watch监视，会第一时间尝试将自己注册为/controller节点。
3. 当某个broker失联后，控制器通过观察zk路径，就知道哪些分区失去了leader,控制器会从该分区的跟随者副本中选择一个充当分区leader。

首选首领：即分区leader，创建topic时，控制器会依据各broker的负载选取该分区的首领。

请求：无论生产者消费者都必须将请求发送对应分区首领上，才能获得正常的响应，否则，就会得到一个非对应首领的错误，此时客户端会先请求broker（broker会缓存zk上的元数据信息，topic，分区，分区首领等）元数据，通过元数据获取正确的broker，才能正常的发送/拉取消息。

**生产者的acks值只能是0，1，all。**

跟随者副本：是指未跟上首领副本的broker，当数据都同步完成，跟上首领副本时，会转变为同步副本。

同步副本：是指跟上首领副本的broker。

消息必须都在同步副本上都存储之后，该消息才能被消费者甚至和跟随者副本拉取到。（数据未同步前，认为该数据是不安全的，因为有可能此时分区首领宕机）。

kafka是采用**零复制**的机制将数据传递给其他副本或者消费者的。



### 排序算法

算法特性：

1. 稳定性：若元素a=b，交换后，ab位置保持不变，则该算法具有稳定性。
2. 时间复杂度：
3. 空间复杂度：

算法的分类：

1. 比较类：

   1. 交换排序：
      1. **冒泡排序：** 依次比较相邻元素，(若不符合顺序)交换相邻元素，每轮的最值将被置换到最后，排除本轮最末位的元素，继续重复下轮，直到剩最后一个元素。
      2. **快速排序：** 选择一个基准点，将小于基准值的元素放在左边，形成两个子序列（分区），在迭代上一步骤，直到所有子序列不可再分割。迭代分区。
   2. 插入排序：
      1. 简单插入排序：以第一个元素为已排序子序列，后边的元素不断向已排序的子序列的合适位置进行插入。
      2. 希尔排序：
   3. 选择排序：
      1. 简单选择排序：
      2. 堆排序：
   4. 归并排序：
      1. 二路归并排序：将两个有序的子序列合并成一个大的有序序列。
      2. 多路归并排序：

2. 非比较类：

   1. 计数排序

   2. 桶排序

   3. 基数排序




分布式锁：

1. 基于数据库：
2. 基于redis：
3. 基于zk实现：

常用序列化方式：

特性：空间压缩比，速度，

1. jdk：简单易用，性能差，安全问题。
2. json：可观星
3. hession
4. protostuff：Google出品，但需要基础配置，压缩率较高，速度快。
5. kryo：

### CompletableFuture

1. 相比Future添加了回调函数。执行成功回调.thenAccept(consumer) / .thenAcceptAsync(Consumer)/ .thenAccpetAsyncBoth(consumer...)，异常回调.exceptionally(consumer)。

2. 多个CompletableFuture可以**串行/并行** 执行，其实相当于回调函数也是一个CompletableFuture实例。

   > 引用场景：1. 消息推送，分批次推送(五个线程每个线程处理一页数据) 2. 下单校验时，需要校验用户、商品、收件人等信息，分开校验。





项目中遇到过的问题：

线上问题排查：

> 1. 登录状态问题。cookie数量导致的.
> 2. 秒杀系统压测。TPS上不去的问题。
> 3. 数据一致性问题（GP和MYSQL库），三重解决（1.失败入队列，2.零点核对，3.自动补数据）。

组内定位：

锁的作用：保证 可见性，原子性和有序性。



-XX:-UseBiasedLocking来禁用偏向锁

I/O模型

> 1. 阻塞模式：读写命令会导致当前命令阻塞，直到读写完成。
> 2. 非阻塞模式：读写命令会直接返回，需要程序不断轮询读写结果，当前同一个线程执行读写和轮询命令。
> 3. 多路复用：在非阻塞模式的基础上，选一个或多个线程对n个读写命令进行轮询。
> 4. 信号驱动I/O：在读写命令时，添加SIGIO信号对fd状态和用户线程进行关联，当fd状态变更时(可读/可写)，内核会通知用户线程进行读写操作。
> 5. 异步I/O：在用户线程发出读写命令，直接返回，并添加SIGIO信号量进行用户关联线程操作，当fd状态变更时，内核会主动将数据复制到用户空间中，与前四种模型相比，该模型只有读的操作，而无查询状态的操作。





达达：

> 1. 讲讲对JMM的理解（内存模型 + 执行流程）。
> 2. 垃圾回收算法和常用的垃圾回收器，日常JVM调优的内容点都有哪些。
> 3. 谈谈对Spring的理解，对spring的扩展点都有哪些，手动注册Bean都有哪些方式（两种）。
> 4. 谈谈对多线程的理解，synchronized的实现方式，与Lock的区别。
> 5. 线程池的核心参数都有哪些，具体流程是如何实现的。
> 6. 谈谈CAP理论，实际项目中是如何落实的。

得物：

> 1. 类加载机制（从java.exe调起虚拟机讲起）
> 2. JVM内存模型
> 3. 并发锁实现、缓存一致性锁升级、锁升级(注意点：问到标志位值1代表什么，怎么知道偏向锁偏向的是哪个线程)。
> 4. JVM调优。
> 5. GC算法工作原理。
> 6. MVCC原理。
> 7. 线程池 参数，线程状态扭转，工作原理，应用场景。
> 8. redis分布式锁的实现。
> 9. ShardingSphere分库分表。
> 10. rabbitmq消息保障怎么做。
> 11. elasticsearch怎么同步数据库的数据

途虎：

> 一面：
>
> 1. MySQL的锁类型（行锁，表锁，间隙锁），具体案例什么情况下会用到什么锁。
> 2. MySQL索引结构，查询时如何利用索引进行查询的，MySQL将索引加载到内存后是如何定位数据的。
> 3. redis和MySQL的区别。
>
> 二面：
>
> 1. 介绍下最近在做的项目，项目中有哪些难点或者亮点，该项目有哪些地方还有提升的空间。
> 2. 画一下你们公司的整体技术架构。
> 3. 用户表体量是多少，分表了吗，分表依据是什么。

微盟：

> 一面（刚开始技术官没有拿到自己的简历）：
>
> 1. 介绍一下自己。
> 2. 你们公司用的技术架构是什么。
> 3. 平时看过源码吗，都看过哪些（自己谈到了队列，被问到阻塞队列的原理）。
> 4. ThreadLocal用过吗，应用的场景是什么，数据结构是什么，数据是保存在哪个地方的。
> 5. 谈谈对多线程的理解，由这一个概念延伸到了锁机制，线程切换，具体点下面分别说。
> 6. 锁机制：synchronized如何实现的，可能会造成死锁吗，与Lock的区别，Lock是如何实现的。
> 7. 怎么理解线程切换的概念，线程切换都需要做哪些工作，慢究竟是慢到哪个地方了。
> 8. wait，sleep和park的区别。
> 9. 如何对native方法进行调用，native方法放在哪个包下，和普通方法有什么区别。
> 10. redis单线程会快，为什么快。
>
> 二面：
>
> 1. 介绍下你负责的都有哪些项目，你觉得哪个项目最有难度，画下他的架构。
> 2. 该项目的体量是多少，对比升级前的系统提升在哪些地方（我介绍的是消息推送系统的升级版本），在此基础上还有哪些地方有提升的空间。
> 3. 你在你们组里是一个什么定位。
> 4. 对薪资要求。

小鱼易连：

> 1. 讲下TCP的三次握手和四次挥手的过程。
> 2. 讲下Http和Https的区别，浏览器如何进行证书的认证的。
> 3. 讲讲TheadLocal。
> 4. 讲讲volatile的特性，实现原理是什么（内存屏障：生成一个lock前缀指令，三个作用：禁止内存屏障前后指令颠倒顺序，写操作会强制刷入主内存，写操作会导致其他线程中的缓存失效）。
> 5. 讲讲synchronize和Lock的区别。
> 6. 公平锁和非公平锁有什么区别。
> 7. JDK的线程池用的是可重入锁吗（回答的不是，没继续深入问，现在回想线程池里的锁应该是指addWorker时的锁吧，不太确定）。
> 8. 分别讲讲HashMap和ConcurrentHashMap的区别 及put时的过程是什么样的。
> 9. 你都了解哪些垃圾回收算法。
> 10. redis是单线程的吗。
> 11. kafka是如何保证高吞吐量的（通过多个partion和零复制技术。回答时没回答零复制技术？）。
> 12. 编程题：有一个无序数组，找出其中三个数字 其结果为0的不同组合。





## springboot

## Zookeeper

## Mybatis

## Redis

## Nginx

## ES搜索引擎

## FastDFS

## 分布式会话

## 单点登录

## rabbitMq消息队列

## kafka消息队列

## MyCat

## sharding-jdbc

## 分布式锁设计

## 分布式全局ID设计

## 分布式事务和数据一致性

## 接口幂等性设计

## 分布式限流

## springcloud 微服务

## Docker

## K8S

## 容器弹性扩容

## Netty

## JVM 性能调优

## MySQL性能调优

## Tomcat性能调优

## 应用程序调优

## Linux性能调优

## 架构调优
